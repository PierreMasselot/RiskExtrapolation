################################################################################
#
#   New extensions
#   2. Vulnerability factors
#
################################################################################

############################################
# MODEL WITH COMPOSITE INDICES OF VULNERABILITY
############################################

#---------------------
# Reduce dimension
#---------------------

# Maximum number of components
maxk <- 10

# In each method, variables are standardized beforehand
# Note that the replication for various age groups can change the standardization
# If age-group are not constant between locations, it might be better to
# standardize befor expanding.

#----- First possibility: PCA

# Compute PCA
pcares <- prcomp(metapred, center = TRUE, scale = TRUE)

# Extract PCs
pca_comp <- pcares$x

# Correlation with original metapredictors
pca_coords <- t(apply(pcares$rotation, 1, "*", pcares$sdev))

#----- Second possibility: PLS

# Compute PLSR (basic PLS computed as a linear model)
plsres <- plsr(coefs ~ metapred, scale = T)

# Extract scores
pls_comp <- predict(plsres, newdata = metapred, type = "scores")
colnames(pls_comp) <- sprintf("Comp%i", 1:ncol(metapred))

# Correlation with original metapredictors
pls_coords <- plsres$loadings

#----- Third possibility: CCA
# Mostly useful when the response (ERF) is multidimensional

# Compute CCA
ccares <- cancor(scale(metapred), coefs)

# Create new metavariables
cca_comp <- scale(metapred) %*% ccares$xcoef
colnames(cca_comp) <- sprintf("Comp%i", 1:ncol(metapred))

# Correlation with original metapredictors
cca_coords <- cor(metapred, cca_comp)

#---------------------
# Select the best indices
#---------------------

#----- Apply models with various number of components

# Baseline model: no component
baseform <- coefs ~ ns(age, knots = 60)
basemeta <- mixmeta(baseform, random = ranform, data = stage2df, S = vcovs)

# Update formula
compform <- update(baseform, "~ . + comp")

# PCA
pcameta <- foreach(k = seq_len(maxk)) %do% {
  comp <- pca_comp[,1:k]
  mixmeta(compform, random = ranform, data = stage2df, S = vcovs)
}

# PLS
plsmeta <- foreach(k = seq_len(maxk)) %do% {
  comp <- pls_comp[,1:k]
  mixmeta(compform, random = ranform, data = stage2df, S = vcovs)
}

# CCA
ccameta <- foreach(k = seq_len(maxk)) %do% {
  comp <- cca_comp[,1:k]
  mixmeta(compform, random = ranform, data = stage2df, S = vcovs)
}

#----- Choose best model

# Compute AIC
aicbase <- AIC(basemeta)
aicpca <- sapply(pcameta, AIC)
aicpls <- sapply(plsmeta, AIC)
aiccca <- sapply(ccameta, AIC)

# Best model as lowest AIC
allaic <- cbind(aicpca, aicpls, aiccca)
bestmod <- which(allaic == min(allaic), arr.ind = T)

# Extract best model
stage2res <- list(pcameta, plsmeta, ccameta)[[bestmod[2]]][bestmod[1]]

############################################
# Plot results
############################################

# Parameters on what models to display
compmod <- "pls"
maxcomp <- 3
citypred <- "IT002C"

#------------------
# Model selection
#------------------

# Choose aesthetic
pal <- mako(ncol(allaic), end = .8)
pch  <- 16
lty <- seq_len(ncol(allaic))

# Plot
matplot(0:maxk, rbind(aicbase, allaic), type = "b", pch = pch, lty = lty,
  col = pal, xlab = "# of components", ylab = "AIC")
points(0, aicbase, pch = pch)

# Add legend
legend("bottomleft", legend = c("PCA", "PLS", "CCA"), pch = pch, lty = lty,
  col = pal, bty = "n", horiz = T)

#------------------
# Correlation with initial variables
#------------------

# Select right coordinates
coord_plot <- get(sprintf("%s_coords", compmod))[,1:maxcomp, drop = F]
rownames(coord_plot) <- names(metaprednames)

# Color scale
pal <- scico(200, palette = "cork")

# Plot coordinates
corrplot(t(coord_plot), method = "square", is.corr = F, col.lim = c(-1, 1), 
  tl.srt = 45, tl.col = "black", cl.cex = .7, cl.align.text = "l",
  col = pal, cl.length = 5)

# Save
dev.print(pdf, file = "figures/Fig2a_compcor.pdf")

#------------------
# Evolution of curve for a city
#------------------

#----- Prepare ERFs

# Predict from various models
ind <- which(stage2df$city == citypred)[5]
comp_pred <- c(
  list(predict(basemeta, vcov = T)[[ind]]),
  lapply(1:maxcomp, function(k){
    predict(get(sprintf("%smeta", compmod))[[k]], vcov = T)[[ind]]
  })
)

# Create ERFs
comp_erf <- lapply(comp_pred, function(x){
  firstpred <- mmtbasis %*% x$fit
  mmt <- mmtper[which.min(firstpred)]
  crosspred(ovbasis, coef = x$fit, vcov = x$vcov, model.link = "log", 
    at = ovper, cen = mmt)
})

# ERF for first-stage
firstpred <- mmtbasis %*% coefs[ind,]
mmt <- mmtper[which.min(firstpred)]
firsterf <- crosspred(ovbasis, coef = coefs[ind,], vcov = vcovs[[ind]], 
  model.link = "log", at = ovper, cen = mmt)

#----- Plot

# Color palette
comppal <- mako(maxcomp + 1, end = .8)

# Initialize plot, draw grid and custom x-axis
plot(NA, bty = "l", xaxt = "n", 
  xlab = "Temperature percentile", ylab = "RR",
  xlim = range(ovper), ylim = c(.8, 2))
abline(v = ovaxis, h = axTicks(2), lty = 2, col = "lightgrey")
axis(1, at = ovaxis, labels = axisper)

# Add age curves
for (i in seq_along(comp_erf)){
  lines(comp_erf[[i]], ptype = "overall", col = comppal[i], ci = "n", 
    lwd = 2, ci.arg = list(col = adjustcolor(comppal[i], .2)))
}

# Add first stage curve
lines(firsterf, ptype = "overall", col = 2, ci = "n", lty = 2, 
  lwd = 2, ci.arg = list(col = adjustcolor(2, .2)))

# Overlay the RR=1 line
abline(h = 1)

# Add legend
legdim <- legend("top", legend = 0:maxcomp, col = comppal, cex = .8,
  lty = 1, lwd = 2, title = "# Components", horiz = T, xpd = T,
  box.col = "white")
legend(x = mean(par("usr")[1:2]), y = par("usr")[4] - legdim$rect$h, 
  legend = "First-stage", col = 2, lwd = 2, lty = 2, cex = .8,
  box.col = "white", xjust = 0.5)

# Save
dev.print(pdf, file = "figures/Fig2b_examplePred.pdf")